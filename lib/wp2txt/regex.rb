# frozen_string_literal: true

require "htmlentities"
require "json"

module Wp2txt
  # Load MediaWiki aliases from data file (generated by scripts/fetch_mediawiki_data.rb)
  MEDIAWIKI_DATA_PATH = File.join(__dir__, "data", "mediawiki_aliases.json")

  def self.load_mediawiki_data
    return @mediawiki_data if @mediawiki_data

    if File.exist?(MEDIAWIKI_DATA_PATH)
      @mediawiki_data = JSON.parse(File.read(MEDIAWIKI_DATA_PATH))
    else
      # Fallback to minimal defaults if data file is missing
      @mediawiki_data = {
        "magic_words" => { "redirect" => ["REDIRECT"] },
        "namespaces" => { "category" => ["Category"], "file" => ["File", "Image"] }
      }
    end
    @mediawiki_data
  end
  ###################################################
  # variables to save resource for generating regexps
  # those with a trailing number 1 represent opening tag/markup
  # those with a trailing number 2 represent closing tag/markup
  # those without a trailing number contain both opening/closing tags/markups

  HTML_DECODER = HTMLEntities.new

  ENTITIES = ['&nbsp;', '&lt;', '&gt;', '&amp;', '&quot;'].zip([' ', '<', '>', '&', '"'])
  HTML_HASH = Hash[*ENTITIES.flatten]
  HTML_REGEX = Regexp.new("(" + HTML_HASH.keys.join("|") + ")")

  # Mathematical and special entities not covered by HTMLEntities gem
  MATH_ENTITIES = {
    "&ell;" => "ℓ",           # Script small L
    "&varepsilon;" => "ε",    # Greek epsilon
    "&epsilon;" => "ε",       # Greek epsilon
    "&setminus;" => "∖",      # Set minus
    "&in;" => "∈",            # Element of
    "&notin;" => "∉",         # Not element of
    "&subset;" => "⊂",        # Subset
    "&supset;" => "⊃",        # Superset
    "&subseteq;" => "⊆",      # Subset or equal
    "&supseteq;" => "⊇",      # Superset or equal
    "&forall;" => "∀",        # For all
    "&exist;" => "∃",         # Exists
    "&nabla;" => "∇",         # Nabla
    "&partial;" => "∂",       # Partial derivative
    "&infin;" => "∞",         # Infinity
    "&empty;" => "∅",         # Empty set
    "&isin;" => "∈",          # Element of (alias)
    "&cap;" => "∩",           # Intersection
    "&cup;" => "∪",           # Union
    "&int;" => "∫",           # Integral
    "&sum;" => "∑",           # Summation
    "&prod;" => "∏",          # Product
    "&radic;" => "√",         # Square root
    "&prop;" => "∝",          # Proportional to
    "&equiv;" => "≡",         # Equivalent
    "&ne;" => "≠",            # Not equal
    "&le;" => "≤",            # Less than or equal
    "&ge;" => "≥",            # Greater than or equal
    "&sim;" => "∼",           # Similar to
    "&asymp;" => "≈",         # Approximately equal
    "&perp;" => "⊥",          # Perpendicular
    "&sdot;" => "⋅",          # Dot operator
    "&lceil;" => "⌈",         # Left ceiling
    "&rceil;" => "⌉",         # Right ceiling
    "&lfloor;" => "⌊",        # Left floor
    "&rfloor;" => "⌋",        # Right floor
    "&lang;" => "⟨",          # Left angle bracket
    "&rang;" => "⟩",          # Right angle bracket
    "&loz;" => "◊",           # Lozenge
    "&oplus;" => "⊕",         # Circled plus
    "&otimes;" => "⊗",        # Circled times
    "&Alpha;" => "Α", "&alpha;" => "α",
    "&Beta;" => "Β", "&beta;" => "β",
    "&Gamma;" => "Γ", "&gamma;" => "γ",
    "&Delta;" => "Δ", "&delta;" => "δ",
    "&Epsilon;" => "Ε",
    "&Zeta;" => "Ζ", "&zeta;" => "ζ",
    "&Eta;" => "Η", "&eta;" => "η",
    "&Theta;" => "Θ", "&theta;" => "θ",
    "&Iota;" => "Ι", "&iota;" => "ι",
    "&Kappa;" => "Κ", "&kappa;" => "κ",
    "&Lambda;" => "Λ", "&lambda;" => "λ",
    "&Mu;" => "Μ", "&mu;" => "μ",
    "&Nu;" => "Ν", "&nu;" => "ν",
    "&Xi;" => "Ξ", "&xi;" => "ξ",
    "&Omicron;" => "Ο", "&omicron;" => "ο",
    "&Pi;" => "Π", "&pi;" => "π",
    "&Rho;" => "Ρ", "&rho;" => "ρ",
    "&Sigma;" => "Σ", "&sigma;" => "σ", "&sigmaf;" => "ς",
    "&Tau;" => "Τ", "&tau;" => "τ",
    "&Upsilon;" => "Υ", "&upsilon;" => "υ",
    "&Phi;" => "Φ", "&phi;" => "φ",
    "&Chi;" => "Χ", "&chi;" => "χ",
    "&Psi;" => "Ψ", "&psi;" => "ψ",
    "&Omega;" => "Ω", "&omega;" => "ω",
    # Wikipedia-specific entities
    "&ratio;" => "∶",          # Ratio symbol
    "&dash;" => "–",           # En-dash (Wikipedia custom)
    "&nbso;" => " "            # Common typo for &nbsp;
  }.freeze
  MATH_ENTITIES_REGEX = Regexp.new("(" + MATH_ENTITIES.keys.map { |k| Regexp.escape(k) }.join("|") + ")")
  ML_TEMPLATE_ONSET_REGEX = Regexp.new('^\{\{[^\}]*$')
  ML_TEMPLATE_END_REGEX = Regexp.new('\}\}\s*$')
  # Match lines starting with [[ that don't end with ]] (handles inner links)
  ML_LINK_ONSET_REGEX = Regexp.new('^\[\[(?!.*\]\]\s*$).*$')
  ML_LINK_END_REGEX = Regexp.new('\]\]\s*$')
  ISOLATED_TEMPLATE_REGEX = Regexp.new('^\s*\{\{.+\}\}\s*$')
  ISOLATED_TAG_REGEX = Regexp.new('^\s*\<[^\<\>]+\>.+\<[^\<\>]+\>\s*$')
  IN_LINK_REGEX = Regexp.new('^\s*\[.*\]\s*$')
  IN_INPUTBOX_REGEX = Regexp.new('<inputbox>.*?<\/inputbox>')
  IN_INPUTBOX_REGEX1 = Regexp.new('<inputbox>')
  IN_INPUTBOX_REGEX2 = Regexp.new('<\/inputbox>')
  IN_SOURCE_REGEX = Regexp.new('<source.*?>.*?<\/source>')
  IN_SOURCE_REGEX1 = Regexp.new('<source.*?>')
  IN_SOURCE_REGEX2 = Regexp.new('<\/source>')
  IN_MATH_REGEX = Regexp.new('<math.*?>.*?<\/math>')
  IN_MATH_REGEX1 = Regexp.new('<math.*?>')
  IN_MATH_REGEX2 = Regexp.new('<\/math>')
  IN_HEADING_REGEX = Regexp.new('^=+.*?=+\s*$')
  IN_HTML_TABLE_REGEX = Regexp.new("<table.*?><\/table>")
  IN_HTML_TABLE_REGEX1 = Regexp.new('<table\b')
  IN_HTML_TABLE_REGEX2 = Regexp.new('<\/\s*table>')
  # HTML comments (can span multiple lines)
  HTML_COMMENT_REGEX = Regexp.new('<!--.*?-->', Regexp::MULTILINE)
  IN_TABLE_REGEX1 = Regexp.new('^\s*\{\|')
  IN_TABLE_REGEX2 = Regexp.new('^\|\}.*?$')
  IN_UNORDERED_REGEX = Regexp.new('^\*')
  IN_ORDERED_REGEX = Regexp.new('^\#')
  IN_PRE_REGEX = Regexp.new('^ ')
  IN_DEFINITION_REGEX = Regexp.new('^[\;\:]')
  BLANK_LINE_REGEX = Regexp.new('^\s*$')

  # Multilingual redirect keyword support
  # Data source: MediaWiki API (siteinfo) via scripts/fetch_mediawiki_data.rb
  REDIRECT_KEYWORDS = load_mediawiki_data.dig("magic_words", "redirect")&.join("|") || "REDIRECT"
  REDIRECT_REGEX = Regexp.new('[#＃](?:' + REDIRECT_KEYWORDS + ')\s*:?\s*\[\[([^\]]+)\]\]', Regexp::IGNORECASE)
  REMOVE_TAG_REGEX = Regexp.new("\<[^\<\>]*\>")
  REMOVE_DIRECTIVES_REGEX = Regexp.new("\_\_[^\_]*\_\_")
  REMOVE_EMPHASIS_REGEX = Regexp.new('(' + Regexp.escape("''") + '+)(.+?)\1')
  CHRREF_TO_UTF_REGEX = Regexp.new('&#(x?)([0-9a-fA-F]+);')
  MNDASH_REGEX = Regexp.new('\{(mdash|ndash|–)\}')
  REMOVE_HR_REGEX = Regexp.new('^\s*\-{4,}\s*$')
  MAKE_REFERENCE_REGEX_A = Regexp.new('<br ?\/>', Regexp::IGNORECASE)
  MAKE_REFERENCE_REGEX_B = Regexp.new('<ref[^>]*\/>', Regexp::IGNORECASE)
  MAKE_REFERENCE_REGEX_C = Regexp.new('<ref[^>]*>', Regexp::IGNORECASE)
  MAKE_REFERENCE_REGEX_D = Regexp.new('<\/ref>', Regexp::IGNORECASE)
  FORMAT_REF_REGEX = Regexp.new('\[ref\](.*?)\[\/ref\]', Regexp::MULTILINE)
  HEADING_ONSET_REGEX = Regexp.new('^(\=+)\s+')
  HEADING_CODA_REGEX = Regexp.new('\s+(\=+)$')
  LIST_MARKS_REGEX = Regexp.new('\A[\*\#\;\:\ ]+')
  PRE_MARKS_REGEX = Regexp.new('\A\^\ ')
  DEF_MARKS_REGEX = Regexp.new('\A[\;\:\ ]+')
  ONSET_BAR_REGEX = Regexp.new('\A[^\|]+\z')

  # Multilingual category namespace support
  # Data source: MediaWiki API (siteinfo) via scripts/fetch_mediawiki_data.rb
  CATEGORY_NAMESPACES = load_mediawiki_data.dig("namespaces", "category")&.join("|") || "Category"

  # Multilingual file namespace support (for image/file links)
  FILE_NAMESPACES = load_mediawiki_data.dig("namespaces", "file")&.join("|") || "File|Image"
  FILE_NAMESPACES_REGEX = Regexp.new('\A\s*(?:' + FILE_NAMESPACES + ')\s*:', Regexp::IGNORECASE)

  # Image parameters (multilingual) - used for filtering out non-caption parts of File/Image links
  # Combines: img_thumbnail, img_framed, img_frameless, img_border, img_right, img_left, img_center, img_none,
  # img_upright, img_baseline, img_sub, img_super, img_top, img_text_top, img_middle, img_bottom, img_text_bottom
  IMAGE_PARAM_KEYS = %w[img_thumbnail img_framed img_frameless img_border img_right img_left img_center img_none
                        img_upright img_baseline img_sub img_super img_top img_text_top img_middle img_bottom img_text_bottom].freeze
  IMAGE_PARAMS = IMAGE_PARAM_KEYS.flat_map { |k| load_mediawiki_data.dig("magic_words", k) || [] }.uniq.join("|")
  IMAGE_PARAMS_REGEX = IMAGE_PARAMS.empty? ? nil : Regexp.new('\A(' + IMAGE_PARAMS + ')\z', Regexp::IGNORECASE)

  # Cleanup regex patterns using dynamic file namespaces
  # For lines like "Image:file.jpg|thumb|...|caption" (gallery/imagemap remnants)
  CLEANUP_FILE_LINE_REGEX = Regexp.new('^(?:' + FILE_NAMESPACES + '):[^\n]+\|[^\n]+$', Regexp::IGNORECASE | Regexp::MULTILINE)
  # For incomplete File/Image links (opened but not closed)
  CLEANUP_FILE_INCOMPLETE_REGEX = Regexp.new('\[\[(?:' + FILE_NAMESPACES + '):[^\]]*\|?\s*$', Regexp::IGNORECASE | Regexp::MULTILINE)

  CATEGORY_REGEX = Regexp.new('[\{\[\|\b](?:' + CATEGORY_NAMESPACES + ')\s*:(.*?)[\}\]\|\b]', Regexp::IGNORECASE)

  ESCAPE_NOWIKI_REGEX = Regexp.new('<nowiki>(.*?)<\/nowiki>', Regexp::MULTILINE)
  UNESCAPE_NOWIKI_REGEX = Regexp.new('<nowiki\-(\d+?)>')

  REMOVE_ISOLATED_REGEX = Regexp.new('^\s*\{\{(.*?)\}\}\s*$')
  REMOVE_INLINE_REGEX = Regexp.new('\{\{(.*?)\}\}')
  TYPE_CODE_REGEX = Regexp.new('\A(?:lang*|\AIPA|IEP|SEP|indent|audio|small|dmoz|pron|unicode|note label|nowrap|ArabDIN|trans|Nihongo|Polytonic)', Regexp::IGNORECASE)

  SINGLE_SQUARE_BRACKET_REGEX = Regexp.new("(#{Regexp.escape("[")}|#{Regexp.escape("]")})", Regexp::MULTILINE)
  DOUBLE_SQUARE_BRACKET_REGEX = Regexp.new("(#{Regexp.escape("[[")}|#{Regexp.escape("]]")})", Regexp::MULTILINE)
  SINGLE_CURLY_BRACKET_REGEX = Regexp.new("(#{Regexp.escape("{")}|#{Regexp.escape("}")})", Regexp::MULTILINE)
  DOUBLE_CURLY_BRACKET_REGEX = Regexp.new("(#{Regexp.escape("{{")}|#{Regexp.escape("}}")})", Regexp::MULTILINE)
  CURLY_SQUARE_BRACKET_REGEX = Regexp.new("(#{Regexp.escape("{|")}|#{Regexp.escape("|}")})", Regexp::MULTILINE)

  SELF_CLOSING_TAG_REGEX = Regexp.new('<[^<>]+/>')
  COMPLEX_REGEX_01 = Regexp.new('\<\<([^<>]++)\>\>\s?')
  COMPLEX_REGEX_02 = Regexp.new('\[\[File\:((?:[^\[\]]++|\[\[\g<1>\]\])++)\]\]', Regexp::MULTILINE | Regexp::IGNORECASE)
  COMPLEX_REGEX_03 = Regexp.new('^\[\[((?:[^\[\]]++|\[\[\g<1>\]\])++)^\]\]', Regexp::MULTILINE)
  COMPLEX_REGEX_04 = Regexp.new('\{\{(?:infobox|efn|sfn|unreliable source|refn|reflist|col(?:umns)?\-list|div col|no col|bar box|formatnum\:|col\||see also\||r\||#)((?:[^{}]++|\{\{\g<1>\}\})++)\}\}', Regexp::MULTILINE | Regexp::IGNORECASE)
  COMPLEX_REGEX_05 = Regexp.new('\{\{[^{}]+?\n\|((?:[^{}]++|\{\{\g<1>\}\})++)\}\}', Regexp::MULTILINE | Regexp::IGNORECASE)

  CLEANUP_REGEX_01 = Regexp.new('\[ref\]\s*\[\/ref\]', Regexp::MULTILINE)
  CLEANUP_REGEX_02 = Regexp.new('^File:.+$')
  CLEANUP_REGEX_03 = Regexp.new('^\|.*$')
  CLEANUP_REGEX_04 = Regexp.new('\{\{.*$')
  CLEANUP_REGEX_05 = Regexp.new('^.*\}\}')
  CLEANUP_REGEX_06 = Regexp.new('\{\|.*$')
  CLEANUP_REGEX_07 = Regexp.new('^.*\|\}')
  CLEANUP_REGEX_08 = Regexp.new('\n\n\n+', Regexp::MULTILINE)

  # =========================================================================
  # Multilingual cleanup patterns (language-agnostic)
  # =========================================================================

  # MediaWiki magic words (universal across all wikis)
  # DEFAULTSORT, DISPLAYTITLE, etc.
  # Note: Use [^\n]+ instead of .+ because Ruby's MULTILINE makes . match newlines
  MAGIC_WORD_LINE_REGEX = Regexp.new('^(DEFAULTSORT|DISPLAYTITLE):[^\n]+$')

  # Double-underscore magic words: __NOTOC__, __TOC__, __FORCETOC__, __NOEDITSECTION__, etc.
  DOUBLE_UNDERSCORE_MAGIC_REGEX = Regexp.new('__[A-Z]+__')

  # Interwiki links: :en:Article, :fr:Article, :de:Article, etc.
  # Removes the prefix but keeps the article name
  INTERWIKI_PREFIX_REGEX = Regexp.new(':([a-z]{2,3}):(?=[^\s\]]+)')

  # Authority control and metadata templates (standalone lines)
  # These are template names that appear alone on a line after processing
  AUTHORITY_CONTROL_REGEX = Regexp.new(
    '^\s*(Normdaten|Authority\s*control|Persondata|Taxonbar|Speciesbox|' \
    'Coord|Coord\s*missing|GND|VIAF|LCCN|BNF|NLA|NDL|SUDOC|ISNI|ORCID)\s*$',
    Regexp::MULTILINE | Regexp::IGNORECASE
  )

  # Category line patterns for major Wikipedia languages
  # This covers: Category (en), カテゴリ (ja), Kategorie (de), Catégorie (fr),
  # Categoría (es), Categoria (it/pt), Категория (ru), 分类 (zh), etc.
  # Note: Must NOT match "CATEGORIES:" (our summary line)
  CATEGORY_LINE_REGEX = Regexp.new(
    '^\s*\*?\s*(?!' \
    'CATEGORIES)(' \
    'Category|カテゴリ|Kategorie|Catégorie|Categoría|Categoria|' \
    'Категория|Категорія|分类|分類|تصنيف|زمرہ|' \
    'Categorie|Kategori|Luokka|Kategória|Κατηγορία|Kategoria' \
    '):[^\n]+$',
    Regexp::MULTILINE
  )

  # Wikimedia sister project markers (standalone lines)
  WIKIMEDIA_PROJECT_REGEX = Regexp.new(
    '^\s*(Wikibooks|Wikiversity|Wikisource|Wikiquote|Wikinews|' \
    'Wiktionary|Wikivoyage|Wikispecies|Wikidata|Wikimedia\s*Commons|' \
    'Commons|Commons\s*cat(?:egory)?|School)(?::|$)',
    Regexp::MULTILINE | Regexp::IGNORECASE
  )

  # Lines that are just a single asterisk (list marker without content)
  LONE_ASTERISK_REGEX = Regexp.new('^\s*\*\s*$', Regexp::MULTILINE)

  # =========================================================================
  # Non-article namespace prefixes (for validation filtering)
  # =========================================================================
  # These are namespaces that should be excluded from article validation
  # as they contain templates, portals, help pages, etc. not encyclopedia content
  #
  # Includes major Wikipedia languages: en, ja, zh, ko, ru, ar, de, fr, es, it, pt, nl, pl, etc.
  NON_ARTICLE_NAMESPACES = [
    # Wikipedia/Project namespace
    "Wikipedia", "WP", "Project",
    "ウィキペディア", "Wikipedia_talk",
    "维基百科", "維基百科",
    "위키백과", "백:백과사전",
    "Википедия", "ВП",
    "ويكيبيديا", "وب",
    "Wikipedie", "Wikipédia", "Vikipedi", "Βικιπαίδεια",

    # MediaWiki namespace (usually same across languages)
    "MediaWiki", "MW",
    "ميدياويكي", "미디어위키",

    # Template namespace
    "Template", "T",
    "テンプレート",
    "模板",
    "틀",
    "Шаблон",
    "قالب",
    "Vorlage", "Modèle", "Plantilla", "Predefinição", "Sjabloon", "Szablon", "Πρότυπο",

    # Portal namespace
    "Portal", "P",
    "ポータル",
    "门户",
    "포털",
    "Портал",
    "بوابة",

    # Help namespace
    "Help", "H",
    "ヘルプ",
    "帮助", "幫助",
    "도움말",
    "Справка",
    "مساعدة",
    "Hilfe", "Aide", "Ayuda", "Ajuda",

    # Category namespace (use existing data)
    "Category", "Cat",
    "カテゴリ",
    "分类", "分類",
    "분류",
    "Категория", "Категорія",
    "تصنيف",
    "Kategorie", "Catégorie", "Categoría", "Categoria",

    # File/Image namespace (use existing data)
    "File", "Image",
    "ファイル", "画像",
    "文件", "档案", "圖像",
    "파일",
    "Файл", "Изображение",
    "ملف", "صورة",
    "Datei", "Fichier", "Archivo", "Ficheiro",

    # User namespace
    "User", "U",
    "利用者",
    "用户", "用戶",
    "사용자",
    "Участник", "Користувач",
    "مستخدم",
    "Benutzer", "Utilisateur", "Usuario", "Usuário",

    # Talk namespaces (various)
    "Talk",
    "ノート", "トーク",
    "讨论", "討論",
    "토론",
    "Обсуждение", "Обговорення",
    "نقاش",
    "Diskussion", "Discussion", "Discusión", "Discussão",

    # Module namespace (Lua scripts)
    "Module", "Mod",
    "モジュール",
    "模块", "模組",
    "모듈",
    "Модуль",
    "وحدة",

    # TimedText, Gadget, etc.
    "TimedText", "Gadget", "Gadget definition",

    # Draft namespace
    "Draft",
    "下書き",
    "草稿",

    # Book namespace
    "Book",
    "ブック",
    "册",

    # WikiProject namespace
    "WikiProject", "WP",
    "プロジェクト",
    "维基专题", "維基專題",
    "위키프로젝트",
    "Проект",
    "مشروع",
  ].freeze

  # Build regex for matching non-article titles
  # Matches "Namespace:Title" where Namespace is in the list
  NON_ARTICLE_NAMESPACE_REGEX = Regexp.new(
    '\A\s*(' + NON_ARTICLE_NAMESPACES.map { |ns| Regexp.escape(ns) }.join("|") + ')\s*:',
    Regexp::IGNORECASE
  )

  # Helper method to check if a title is an article page (not a special namespace)
  def self.article_page?(title)
    return true if title.nil? || title.empty?
    !(title =~ NON_ARTICLE_NAMESPACE_REGEX)
  end
end
