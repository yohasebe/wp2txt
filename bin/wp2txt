#!/usr/bin/env ruby

# frozen_string_literal: true

require_relative "../lib/wp2txt"
require_relative "../lib/wp2txt/utils"
require_relative "../lib/wp2txt/version"
require_relative "../lib/wp2txt/cli"
require_relative "../lib/wp2txt/multistream"
require_relative "../lib/wp2txt/cli_ui"
require_relative "../lib/wp2txt/formatter"
require_relative "../lib/wp2txt/extractor"

require "etc"
require "json"
require "optimist"
require "parallel"
require "pastel"
require "tty-spinner"
require "tty-progressbar"

class WpApp
  include Wp2txt
  include Wp2txt::CliUI
  include Wp2txt::Formatter
  include Wp2txt::Extractor

  # Maximum number of processors that can be used for parallel processing
  MAX_PROCESSORS = 8
  # Debug mode flag
  DEBUG_MODE = false

  def initialize
    @pastel = Pastel.new
  end

  private

  # Calculate the number of processes to be used for parallel processing
  def calculate_num_processes(opts)
    num_processors = Etc.nprocessors
    if opts[:num_procs] && opts[:num_procs].to_i <= num_processors && opts[:num_procs].to_i <= MAX_PROCESSORS
      opts[:num_procs]
    else
      minus2 = num_processors - 2
      minus2 < MAX_PROCESSORS ? minus2 : MAX_PROCESSORS
    end.tap { |n| n = 1 if n < 1 }
  end

  # Process articles using streaming (new architecture)
  def process_stream(input_path, output_dir, config)
    num_processes = config[:num_procs]
    file_size_mb = config[:file_size]
    format = config[:format]
    bz2_gem = config[:bz2_gem]

    # Determine base name for output files
    base_name = File.basename(input_path, ".*")
    base_name = base_name.sub(/\.xml$/, "") # Handle .xml.bz2

    # Create stream processor
    stream = StreamProcessor.new(input_path, bz2_gem: bz2_gem)

    # Create output writer
    writer = OutputWriter.new(
      output_dir: output_dir,
      base_name: base_name,
      format: format,
      file_size_mb: file_size_mb
    )

    # Collect pages for parallel processing
    pages = []
    page_count = 0

    print_mode_banner("Full Dump Processing", {
      "Input" => File.basename(input_path),
      "Format" => format.to_s,
      "CPU cores" => num_processes.to_s
    })

    # Initialize progress spinner
    spinner = create_spinner("Processing articles...")
    spinner.auto_spin

    time_start = Time.now
    last_update_time = Time.now

    # Process in batches for memory efficiency
    batch_size = num_processes * 100
    strip_tmarker = !config[:marker]

    stream.each_page do |title, text|
      pages << [title, text]
      page_count += 1

      # Throttle spinner updates to prevent flickering (update at most every 100ms)
      now = Time.now
      if now - last_update_time >= 0.1
        spinner.update(title: "(#{page_count} articles)")
        last_update_time = now
      end

      # Process batch when full
      next unless pages.size >= batch_size

      process_batch(pages, writer, config, strip_tmarker, num_processes)
      pages.clear
    end

    # Process remaining pages
    process_batch(pages, writer, config, strip_tmarker, num_processes) unless pages.empty?

    # Close output
    output_files = writer.close

    time_elapsed = Time.now - time_start
    spinner.success(pastel.green("Done!"))

    # Summary
    print_summary("Processing Complete", {
      "Articles" => page_count.to_s,
      "Output files" => output_files.size.to_s,
      "Time" => format_duration(time_elapsed)
    }, status: :success)

    puts
    puts pastel.dim("Output files:")
    output_files.each { |f| print_list_item(f, status: :success) }
  end

  # Process a batch of pages in parallel
  def process_batch(pages, writer, config, strip_tmarker, num_processes)
    results = Parallel.map(pages, in_processes: num_processes) do |title, text|
      article = Article.new(text, title, strip_tmarker)
      format_article(article, config)
    end

    results.each do |result|
      writer.write(result)
    end
  end

  # Parse --markers option value
  # "all" -> true (all markers enabled)
  # "none" -> DEPRECATED (now treated as "all" with warning)
  # "math,code,chem" -> [:math, :code, :chem]
  def parse_markers_option(value)
    case value.to_s.downcase.strip
    when "all", "true", ""
      true
    when "none", "false"
      # Deprecation warning - none/false no longer removes content completely
      puts @pastel.yellow("Warning: --markers=none is deprecated and will be removed in a future version.")
      puts @pastel.yellow("         Complete removal of special content can make surrounding text nonsensical.")
      puts @pastel.yellow("         Using --markers=all instead. Markers will be shown for all special content.")
      puts
      true  # Treat as "all" instead of removing content
    else
      # Parse comma-separated list
      value.split(",").map { |m| m.strip.downcase.to_sym }.select do |m|
        Wp2txt::MARKER_TYPES.include?(m)
      end
    end
  end

  public

  # Main execution method
  # @return [Integer] Exit code (0=success, 1=error, 2=partial)
  def run
    # Parse command line options using CLI module
    opts = Wp2txt::CLI.parse_options(ARGV)

    # Configure UI settings (color, quiet mode)
    configure_ui(no_color: opts[:no_color], quiet: opts[:quiet])
    reset_pastel!  # Reset pastel to apply color settings
    @pastel = pastel  # Reinitialize with new settings

    # Handle config-init
    if opts[:config_init]
      init_config
      return EXIT_SUCCESS
    end

    # Handle cache operations
    if opts[:cache_status]
      show_cache_status(opts[:cache_dir])
      return EXIT_SUCCESS
    end

    if opts[:cache_clear]
      clear_cache(opts[:cache_dir], opts[:lang])
      return EXIT_SUCCESS
    end

    # Determine input source
    if opts[:from_category] && opts[:lang]
      # Category extraction mode
      return extract_category_articles(opts)
    end

    if opts[:articles] && opts[:lang]
      # Article extraction mode
      return extract_specific_articles(opts)
    end

    input_path = if opts[:lang]
                   download_dump(opts[:lang], opts[:cache_dir])
                 else
                   opts[:input]
                 end

    # Validate format option
    format = opts[:format].to_s.downcase.to_sym

    # Show deprecation warnings
    if opts[:convert_given] || opts[:del_interfile_given]
      print_warning("--convert and --del-interfile options are deprecated and will be ignored.")
      puts pastel.yellow("  Intermediate files are no longer created in v2.0+") unless quiet?
    end

    num_processes = calculate_num_processes(opts)

    # Build configuration hash from options
    config = {
      format: format,
      num_procs: num_processes,
      file_size: opts[:file_size],
      bz2_gem: opts[:bz2_gem]
    }

    %i[title list heading table redirect multiline category category_only
       summary_only marker extract_citations].each do |opt|
      config[opt] = opts[opt]
    end

    # Parse markers option
    config[:markers] = parse_markers_option(opts[:markers])

    # Process input
    process_stream(input_path, opts[:output_dir], config)

    EXIT_SUCCESS
  end

  # Show cache status
  def show_cache_status(cache_dir)
    print_mode_banner("Cache Status", { "Directory" => cache_dir })

    status = Wp2txt::DumpManager.all_cache_status(cache_dir)

    if status.empty?
      print_info_message("No cached dumps found.")
      return
    end

    status.each do |lang, info|
      if info[:error]
        print_list_item("#{lang}: Error - #{info[:error]}", status: :error)
      else
        index_size = info[:index_size] > 0 ? format_size(info[:index_size]) : pastel.dim("not downloaded")
        multistream_size = info[:multistream_size] > 0 ? format_size(info[:multistream_size]) : pastel.dim("not downloaded")
        status_icon = info[:fresh] ? :success : :warning

        puts pastel.bold(lang.to_s.upcase)
        print_list_item("Index: #{index_size}", status: status_icon)
        print_list_item("Multistream: #{multistream_size}", status: status_icon)
        print_info("Date", info[:dump_date] || "unknown", indent: 1)
        puts
      end
    end
  end

  # Clear cache
  def clear_cache(cache_dir, lang = nil)
    if lang
      spinner = create_spinner("Clearing cache for #{lang}...")
      spinner.auto_spin
      manager = Wp2txt::DumpManager.new(lang, cache_dir: cache_dir)
      manager.clear_cache!
      spinner.success(pastel.green("Done!"))
      print_success("Cache cleared for #{lang}.")
    else
      spinner = create_spinner("Clearing all cache...")
      spinner.auto_spin
      Wp2txt::DumpManager.clear_all_cache!(cache_dir)
      spinner.success(pastel.green("Done!"))
      print_success("All cache cleared.")
    end
  end

  # Initialize configuration file
  def init_config
    config_path = Wp2txt::Config.default_path

    if File.exist?(config_path)
      print_warning("Configuration file already exists: #{config_path}")

      unless confirm?("Overwrite?")
        puts "Cancelled."
        return
      end
    end

    Wp2txt::Config.create_default(config_path, force: true)
    print_success("Configuration file created: #{config_path}")
    puts
    puts pastel.dim("Available settings:")
    print_list_item("cache.dump_expiry_days - Days before dump cache expires (default: 30)")
    print_list_item("cache.category_expiry_days - Days before category cache expires (default: 7)")
    print_list_item("cache.directory - Cache directory location")
    print_list_item("defaults.format - Default output format (text/json)")
    print_list_item("defaults.depth - Default subcategory recursion depth")
  end

  # Download dump for a language
  def download_dump(lang, cache_dir)
    app_config = Wp2txt::CLI.config

    print_mode_banner("Auto-Download", {
      "Language" => lang,
      "Cache" => cache_dir
    })

    manager = Wp2txt::DumpManager.new(
      lang,
      cache_dir: cache_dir,
      dump_expiry_days: app_config.dump_expiry_days
    )

    # Check for latest dump
    spinner = create_spinner("Checking for latest dump...")
    spinner.auto_spin
    dump_date = manager.latest_dump_date
    spinner.success(pastel.green(dump_date))

    # Download index and multistream
    print_header("Downloading files")
    manager.download_index
    manager.download_multistream

    print_success("Download complete!")

    # Return path to multistream file
    manager.cached_multistream_path
  end
end

# Handle Ctrl+C gracefully
Signal.trap("INT") do
  # Show cursor (in case it was hidden by spinner/progress bar)
  print "\e[?25h"
  puts "\n\nInterrupted by user."
  exit Wp2txt::CliUI::EXIT_ERROR
end

# Create new instance and run with proper exit code
exit_code = WpApp.new.run
exit(exit_code || Wp2txt::CliUI::EXIT_SUCCESS)
